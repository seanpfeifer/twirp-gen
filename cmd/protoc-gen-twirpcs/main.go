// This is a protoc plugin that generates csharp code for operating with Twirp APIs.
package main

import (
	"flag"
	"strings"
	"text/template"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

const (
	outFileName = "GeneratedAPI.cs"

	fileTemplate = `// <auto-generated>
//     Generated by protoc-gen-twirpcs.  DO NOT EDIT!
// </auto-generated>
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading.Tasks;
using Google.Protobuf; // For ".ToByteArray()"

public class GeneratedAPI {
  public static readonly MediaTypeWithQualityHeaderValue CONTENT_TYPE_PROTOBUF = new MediaTypeWithQualityHeaderValue("application/protobuf");

  public enum ErrorCode {
    NoError, Canceled, Unknown, Invalid_Argument, Malformed, Deadline_Exceeded, Not_Found, Bad_Route, Already_Exists, Permission_Denied,
    Unauthenticated, Resource_Exhausted, Failed_Precondition, Aborted, Out_Of_Range, Unimplemented, Internal, Unavailable, Data_Loss
  };

  public class Exception : System.Exception {
    public readonly ErrorCode Type;

    public Exception(ErrorCode type, string message) : base(message) { Type = type; }
  }

  private static GeneratedAPI.Exception createException(string jsonData) {
    var codeStr = parseJSONString(jsonData, "code");
    if (codeStr == null) {
      return new GeneratedAPI.Exception(ErrorCode.Unknown, jsonData);
    }

    ErrorCode errorCode = ErrorCode.Unknown;
    System.Enum.TryParse<ErrorCode>(codeStr, true, out errorCode);
    var msg = parseJSONString(jsonData, "msg");
    if (msg == null) {
      msg = jsonData;
    }
    return new GeneratedAPI.Exception(errorCode, msg);
  }
  
  private static string parseJSONString(string jsonData, string key) {
    var keyIndex = jsonData.IndexOf(key + "\":\"");
    if (keyIndex == -1) { return null; }
    keyIndex += key.Length + 3;
    var dataEnd = jsonData.IndexOf("\"", keyIndex);
    if (dataEnd == -1) { return null; }
    return jsonData.Substring(keyIndex, dataEnd - keyIndex);
  }

  private delegate Resp doParsing<Resp>(byte[] data) where Resp : IMessage;
  private static async Task<Resp> DoRequest<Req, Resp>(HttpClient client, string address, Req req, doParsing<Resp> parserFunc) where Req : IMessage where Resp : IMessage {
    using (var content = new ByteArrayContent(req.ToByteArray())) {
      content.Headers.ContentType = CONTENT_TYPE_PROTOBUF;
      using (HttpResponseMessage response = await client.PostAsync(address, content)) {
        var byteArr = await response.Content.ReadAsByteArrayAsync();
        if (!response.IsSuccessStatusCode) {
          string errorJSON = System.Text.Encoding.UTF8.GetString(byteArr, 0, byteArr.Length);
          throw createException(errorJSON);
        }
        return parserFunc(byteArr);
      }
    }
  }
{{range .Files}}{{range .Services}}{{range .Methods}}{{$pkg := Title .Desc.ParentFile.Name}}{{$req := .Input.Desc.Name}}{{$resp := .Output.Desc.Name}}
{{Tab .Comments.Leading.String -}}
  public static async Task<{{$pkg}}.{{$resp}}> {{.GoName}}(HttpClient client, {{$pkg}}.{{$req}} req) {
    return await DoRequest<{{$pkg}}.{{$req}}, {{$pkg}}.{{$resp}}>(client, "{{$.PathPrefix}}/{{.Desc.ParentFile.Package}}.{{$pkg}}/{{.GoName}}", req, {{$pkg}}.{{$resp}}.Parser.ParseFrom);
  }
{{end}}{{end}}{{end}}}
`
)

func main() {
	// Set up our flags. The only one we care about for now is the server path prefix.
	var flags flag.FlagSet
	prefix := flags.String("pathPrefix", "/twirp", "the server path prefix to use, if modified from the Twirp default")

	// No special options for this generator
	opts := protogen.Options{ParamFunc: flags.Set}
	opts.Run(func(plugin *protogen.Plugin) error {
		out := plugin.NewGeneratedFile(outFileName, "")

		template, err := template.New("file").
			Funcs(template.FuncMap{"Tab": tabNewlines, "Title": title}).
			Parse(fileTemplate)
		if err != nil {
			return err
		}

		in := jsData{
			Files:      plugin.Files,
			PathPrefix: *prefix,
		}

		return template.Execute(out, in)
	})
}

type jsData struct {
	Files      []*protogen.File
	PathPrefix string
}

// tabNewlines adds tabs (as two spaces) to the beginning of each line in the input string.
func tabNewlines(lines string) string {
	return "  " + strings.Replace(lines, "\n", "\n  ", -1)
}

func title(name protoreflect.Name) string {
	return strings.Title(string(name))
}
